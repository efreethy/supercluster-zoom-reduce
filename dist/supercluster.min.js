!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Supercluster=e()}(this,(function(){"use strict";const t=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class e{static from(s){if(!(s instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[o,i]=new Uint8Array(s,0,2);if(219!==o)throw new Error("Data does not appear to be in a KDBush format.");const n=i>>4;if(1!==n)throw new Error(`Got v${n} data when expected v1.`);const r=t[15&i];if(!r)throw new Error("Unrecognized array type.");const[h]=new Uint16Array(s,2,1),[a]=new Uint32Array(s,4,1);return new e(a,h,r,s)}constructor(e,s=64,o=Float64Array,i){if(isNaN(e)||e<0)throw new Error(`Unpexpected numItems value: ${e}.`);this.numItems=+e,this.nodeSize=Math.min(Math.max(+s,2),65535),this.ArrayType=o,this.IndexArrayType=e<65536?Uint16Array:Uint32Array;const n=t.indexOf(this.ArrayType),r=2*e*this.ArrayType.BYTES_PER_ELEMENT,h=e*this.IndexArrayType.BYTES_PER_ELEMENT,a=(8-h%8)%8;if(n<0)throw new Error(`Unexpected typed array class: ${o}.`);i&&i instanceof ArrayBuffer?(this.data=i,this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+h+a,2*e),this._pos=2*e,this._finished=!0):(this.data=new ArrayBuffer(8+r+h+a),this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+h+a,2*e),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+n]),new Uint16Array(this.data,2,1)[0]=s,new Uint32Array(this.data,4,1)[0]=e)}add(t,e){const s=this._pos>>1;return this.ids[s]=s,this.coords[this._pos++]=t,this.coords[this._pos++]=e,s}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return s(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,s,o){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:n,nodeSize:r}=this,h=[0,i.length-1,0],a=[];for(;h.length;){const c=h.pop()||0,p=h.pop()||0,u=h.pop()||0;if(p-u<=r){for(let r=u;r<=p;r++){const h=n[2*r],c=n[2*r+1];h>=t&&h<=s&&c>=e&&c<=o&&a.push(i[r])}continue}const d=u+p>>1,l=n[2*d],f=n[2*d+1];l>=t&&l<=s&&f>=e&&f<=o&&a.push(i[d]),(0===c?t<=l:e<=f)&&(h.push(u),h.push(d-1),h.push(1-c)),(0===c?s>=l:o>=f)&&(h.push(d+1),h.push(p),h.push(1-c))}return a}within(t,e,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:i,nodeSize:n}=this,h=[0,o.length-1,0],a=[],c=s*s;for(;h.length;){const p=h.pop()||0,u=h.pop()||0,d=h.pop()||0;if(u-d<=n){for(let s=d;s<=u;s++)r(i[2*s],i[2*s+1],t,e)<=c&&a.push(o[s]);continue}const l=d+u>>1,f=i[2*l],m=i[2*l+1];r(f,m,t,e)<=c&&a.push(o[l]),(0===p?t-s<=f:e-s<=m)&&(h.push(d),h.push(l-1),h.push(1-p)),(0===p?t+s>=f:e+s>=m)&&(h.push(l+1),h.push(u),h.push(1-p))}return a}}function s(t,e,i,n,r,h){if(r-n<=i)return;const a=n+r>>1;o(t,e,a,n,r,h),s(t,e,i,n,a-1,1-h),s(t,e,i,a+1,r,1-h)}function o(t,e,s,n,r,h){for(;r>n;){if(r-n>600){const i=r-n+1,a=s-n+1,c=Math.log(i),p=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*p*(i-p)/i)*(a-i/2<0?-1:1);o(t,e,s,Math.max(n,Math.floor(s-a*p/i+u)),Math.min(r,Math.floor(s+(i-a)*p/i+u)),h)}const a=e[2*s+h];let c=n,p=r;for(i(t,e,n,s),e[2*r+h]>a&&i(t,e,n,r);c<p;){for(i(t,e,c,p),c++,p--;e[2*c+h]<a;)c++;for(;e[2*p+h]>a;)p--}e[2*n+h]===a?i(t,e,n,p):(p++,i(t,e,p,r)),p<=s&&(n=p+1),s<=p&&(r=p-1)}}function i(t,e,s,o){n(t,s,o),n(e,2*s,2*o),n(e,2*s+1,2*o+1)}function n(t,e,s){const o=t[e];t[e]=t[s],t[s]=o}function r(t,e,s,o){const i=t-s,n=e-o;return i*i+n*n}const h={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:function(t){return t}},a=Math.fround||(c=new Float32Array(1),function(t){return c[0]=+t,c[0]});var c;const p=3,u=5,d=6;function l(t,e,s){return{type:"Feature",id:t[e+p],properties:f(t,e,s),geometry:{type:"Point",coordinates:[(o=t[e],360*(o-.5)),g(t[e+1])]}};var o}function f(t,e,s){const o=t[e+u],i=o>=1e4?Math.round(o/1e3)+"k":o>=1e3?Math.round(o/100)/10+"k":o,n=t[e+d],r=-1===n?{}:Object.assign({},s[n]);let h;r._byZoom&&null!=r._originZoom?h=r._byZoom[r._originZoom]:r.propertyStatuses&&(h=r.propertyStatuses instanceof Set?Array.from(r.propertyStatuses):r.propertyStatuses);const a={cluster:!0,cluster_id:t[e+p],point_count:o,point_count_abbreviated:i};return h&&h.length>0&&(a.propertyStatuses=h),Object.assign(r,a)}function m(t){return t/360+.5}function y(t){const e=Math.sin(t*Math.PI/180),s=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return s<0?0:s>1?1:s}function g(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}return class{constructor(t){this.options=Object.assign(Object.create(h),t||{});const e=this.options.reduce;e&&(this._userReduce=e,this.options.reduce=(t,s,o)=>{e(t,s,o),t._byZoom=t._byZoom||Object.create(null),t._originZoom=null!=t._originZoom?t._originZoom:o;const i=t.propertyStatuses,n=i instanceof Set?Array.from(i):Array.isArray(i)?i:[];return t._byZoom[o]=n.slice(),t}),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[],this.points=[]}load(t){const e=this.options.log,s=this.options.minZoom,o=this.options.maxZoom;e&&console.time("total time");const i=`prepare ${t.length} points`;e&&console.time(i),this.points=t;const n=[];for(let e=0;e<t.length;e++){const s=t[e];if(!s||!s.geometry)continue;const o=s.geometry.coordinates;if(!Array.isArray(o)||o.length<2)continue;const i=o[0],r=o[1],h=a(m(i)),c=a(y(r));n.push(h,c,1/0,e,-1,1),this.options.reduce&&n.push(0)}let r=this.trees[o+1]=this._createTree(n);e&&console.timeEnd(i);for(let t=o;t>=s;t--){const s=+Date.now();r=this.trees[t]=this._createTree(this._cluster(r,t)),e&&console.log("z%d: %d clusters in %dms",t,r.numItems,+Date.now()-s)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[1]));let i=180===t[2]?180:((t[2]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,i=180;else if(s>i){const t=this.getClusters([s,o,180,n],e),r=this.getClusters([-180,o,i,n],e);return t.concat(r)}const r=this.trees[this._limitZoom(e)],h=r.range(m(s),y(n),m(i),y(o)),a=r.data,c=[];for(let t=0;t<h.length;t++){const e=h[t],s=this.stride*e;c.push(a[s+u]>1?l(a,s,this.clusterProps):this.points[a[s+p]])}return c}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),o="No cluster with the specified id.",i=this.trees[s];if(!i)throw new Error(o);const n=i.data;if(e*this.stride>=n.length)throw new Error(o);const r=this.options.radius/(this.options.extent*Math.pow(2,s-1)),h=n[e*this.stride],a=n[e*this.stride+1],c=i.within(h,a,r),d=[];for(let e=0;e<c.length;e++){const s=c[e]*this.stride;n[s+4]===t&&d.push(n[s+u]>1?l(n,s,this.clusterProps):this.points[n[s+p]])}if(0===d.length)throw new Error(o);return d}getLeaves(t,e,s){e=e||10,s=s||0;const o=[];return this._appendLeaves(o,t,e,s,0),o}getTile(t,e,s){const o=this.trees[this._limitZoom(t)],i=Math.pow(2,t),n=this.options.extent,r=this.options.radius/n,h=(s-r)/i,a=(s+1+r)/i,c={features:[]};return this._addTileFeatures(o.range((e-r)/i,h,(e+1+r)/i,a),o.data,e,s,i,c),0===e&&this._addTileFeatures(o.range(1-r/i,h,1,a),o.data,i,s,i,c),e===i-1&&this._addTileFeatures(o.range(0,h,r/i,a),o.data,-1,s,i,c),c.features.length?c:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,1!==s.length)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,o,i){const n=this.getChildren(e);for(let e=0;e<n.length;e++){const r=n[e],h=r.properties;if(h&&h.cluster?i+h.point_count<=o?i+=h.point_count:i=this._appendLeaves(t,h.cluster_id,s,o,i):i<o?i++:t.push(r),t.length===s)break}return i}_createTree(t){const s=new e(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let e=0;e<t.length;e+=this.stride)s.add(t[e],t[e+1]);return s.finish(),s.data=t,s}_addTileFeatures(t,e,s,o,i,n){for(let r=0;r<t.length;r++){const h=t[r]*this.stride,a=e[h+u]>1;let c,d,l;if(a)c=f(e,h,this.clusterProps),d=e[h],l=e[h+1];else{const t=this.points[e[h+p]];c=t.properties;const s=t.geometry.coordinates[0],o=t.geometry.coordinates[1];d=m(s),l=y(o)}const g={type:1,geometry:[[Math.round(this.options.extent*(d*i-s)),Math.round(this.options.extent*(l*i-o))]],tags:c};let _;_=a||this.options.generateId?e[h+p]:this.points[e[h+p]].id,void 0!==_&&(g.id=_),n.features.push(g)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const s=this.options.radius,o=this.options.extent,i=this.options.reduce,n=this.options.minPoints,r=s/(o*Math.pow(2,e)),h=t.data,a=[],c=this.stride;for(let s=0;s<h.length;s+=c){if(h[s+2]<=e)continue;h[s+2]=e;const o=h[s],p=h[s+1],d=t.within(h[s],h[s+1],r),l=h[s+u];let f=l;for(let t=0;t<d.length;t++){const s=d[t]*c;h[s+2]>e&&(f+=h[s+u])}if(f>l&&f>=n){let t,n=o*l,r=p*l,m=-1;const y=(s/c<<5)+(e+1)+this.points.length;for(let o=0;o<d.length;o++){const a=d[o]*c;if(h[a+2]<=e)continue;h[a+2]=e;const p=h[a+u];if(n+=h[a]*p,r+=h[a+1]*p,h[a+4]=y,i){if(!t){t=this._map(h,s,!0),t._byZoom=Object.create(null),t._originZoom=e;const o=t.propertyStatuses;t._byZoom[e]=o instanceof Set?Array.from(o):Array.isArray(o)?o.slice():[],m=this.clusterProps.length,this.clusterProps.push(t)}i(t,this._map(h,a),e)}}h[s+4]=y,a.push(n/f,r/f,1/0,y,-1,f),i&&a.push(m)}else{for(let t=0;t<c;t++)a.push(h[s+t]);if(f>1)for(let t=0;t<d.length;t++){const s=d[t]*c;if(!(h[s+2]<=e)){h[s+2]=e;for(let t=0;t<c;t++)a.push(h[s+t])}}}}return a}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+u]>1){const o=this.clusterProps[t[e+d]];return s?Object.assign({},o):o}const o=this.points[t[e+p]].properties,i=this.options.map(o);return s&&i===o?Object.assign({},i):i}}}));
