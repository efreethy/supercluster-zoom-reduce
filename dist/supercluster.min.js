!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Supercluster=e()}(this,(function(){"use strict";const t=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class e{static from(s){if(!(s instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[o,r]=new Uint8Array(s,0,2);if(219!==o)throw new Error("Data does not appear to be in a KDBush format.");const n=r>>4;if(1!==n)throw new Error(`Got v${n} data when expected v1.`);const i=t[15&r];if(!i)throw new Error("Unrecognized array type.");const[a]=new Uint16Array(s,2,1),[h]=new Uint32Array(s,4,1);return new e(h,a,i,s)}constructor(e,s=64,o=Float64Array,r){if(isNaN(e)||e<0)throw new Error(`Unpexpected numItems value: ${e}.`);this.numItems=+e,this.nodeSize=Math.min(Math.max(+s,2),65535),this.ArrayType=o,this.IndexArrayType=e<65536?Uint16Array:Uint32Array;const n=t.indexOf(this.ArrayType),i=2*e*this.ArrayType.BYTES_PER_ELEMENT,a=e*this.IndexArrayType.BYTES_PER_ELEMENT,h=(8-a%8)%8;if(n<0)throw new Error(`Unexpected typed array class: ${o}.`);r&&r instanceof ArrayBuffer?(this.data=r,this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+a+h,2*e),this._pos=2*e,this._finished=!0):(this.data=new ArrayBuffer(8+i+a+h),this.ids=new this.IndexArrayType(this.data,8,e),this.coords=new this.ArrayType(this.data,8+a+h,2*e),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+n]),new Uint16Array(this.data,2,1)[0]=s,new Uint32Array(this.data,4,1)[0]=e)}add(t,e){const s=this._pos>>1;return this.ids[s]=s,this.coords[this._pos++]=t,this.coords[this._pos++]=e,s}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return s(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,s,o){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:r,coords:n,nodeSize:i}=this,a=[0,r.length-1,0],h=[];for(;a.length;){const c=a.pop()||0,p=a.pop()||0,u=a.pop()||0;if(p-u<=i){for(let i=u;i<=p;i++){const a=n[2*i],c=n[2*i+1];a>=t&&a<=s&&c>=e&&c<=o&&h.push(r[i])}continue}const d=u+p>>1,l=n[2*d],f=n[2*d+1];l>=t&&l<=s&&f>=e&&f<=o&&h.push(r[d]),(0===c?t<=l:e<=f)&&(a.push(u),a.push(d-1),a.push(1-c)),(0===c?s>=l:o>=f)&&(a.push(d+1),a.push(p),a.push(1-c))}return h}within(t,e,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:r,nodeSize:n}=this,a=[0,o.length-1,0],h=[],c=s*s;for(;a.length;){const p=a.pop()||0,u=a.pop()||0,d=a.pop()||0;if(u-d<=n){for(let s=d;s<=u;s++)i(r[2*s],r[2*s+1],t,e)<=c&&h.push(o[s]);continue}const l=d+u>>1,f=r[2*l],m=r[2*l+1];i(f,m,t,e)<=c&&h.push(o[l]),(0===p?t-s<=f:e-s<=m)&&(a.push(d),a.push(l-1),a.push(1-p)),(0===p?t+s>=f:e+s>=m)&&(a.push(l+1),a.push(u),a.push(1-p))}return h}}function s(t,e,r,n,i,a){if(i-n<=r)return;const h=n+i>>1;o(t,e,h,n,i,a),s(t,e,r,n,h-1,1-a),s(t,e,r,h+1,i,1-a)}function o(t,e,s,n,i,a){for(;i>n;){if(i-n>600){const r=i-n+1,h=s-n+1,c=Math.log(r),p=.5*Math.exp(2*c/3),u=.5*Math.sqrt(c*p*(r-p)/r)*(h-r/2<0?-1:1);o(t,e,s,Math.max(n,Math.floor(s-h*p/r+u)),Math.min(i,Math.floor(s+(r-h)*p/r+u)),a)}const h=e[2*s+a];let c=n,p=i;for(r(t,e,n,s),e[2*i+a]>h&&r(t,e,n,i);c<p;){for(r(t,e,c,p),c++,p--;e[2*c+a]<h;)c++;for(;e[2*p+a]>h;)p--}e[2*n+a]===h?r(t,e,n,p):(p++,r(t,e,p,i)),p<=s&&(n=p+1),s<=p&&(i=p-1)}}function r(t,e,s,o){n(t,s,o),n(e,2*s,2*o),n(e,2*s+1,2*o+1)}function n(t,e,s){const o=t[e];t[e]=t[s],t[s]=o}function i(t,e,s,o){const r=t-s,n=e-o;return r*r+n*n}const a={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},h=Math.fround||(c=new Float32Array(1),t=>(c[0]=+t,c[0]));var c;const p=3,u=5,d=6;function l(t,e,s){return{type:"Feature",id:t[e+p],properties:f(t,e,s),geometry:{type:"Point",coordinates:[(o=t[e],360*(o-.5)),g(t[e+1])]}};var o}function f(t,e,s){const o=t[e+u],r=o>=1e4?`${Math.round(o/1e3)}k`:o>=1e3?Math.round(o/100)/10+"k":o,n=t[e+d],i=-1===n?{}:Object.assign({},s[n]);let a;i._byZoom&&null!=i._originZoom?a=i._byZoom[i._originZoom]:i.propertyStatuses&&(a=i.propertyStatuses instanceof Set?Array.from(i.propertyStatuses):i.propertyStatuses);const h={cluster:!0,cluster_id:t[e+p],point_count:o,point_count_abbreviated:r};return a&&a.length>0&&(h.propertyStatuses=a),Object.assign(i,h)}function m(t){return t/360+.5}function y(t){const e=Math.sin(t*Math.PI/180),s=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return s<0?0:s>1?1:s}function g(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}return class{constructor(t){this.options=Object.assign(Object.create(a),t);const e=this.options.reduce;e&&(this._userReduce=e,this.options.reduce=(t,s,o)=>{e(t,s,o),t._byZoom=t._byZoom||Object.create(null),t._originZoom=null!=t._originZoom?t._originZoom:o;const r=t.propertyStatuses,n=r instanceof Set?Array.from(r):Array.isArray(r)?r:[];return t._byZoom[o]=n.slice(),t}),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[],this.points=[]}load(t){const{log:e,minZoom:s,maxZoom:o}=this.options;e&&console.time("total time");const r=`prepare ${t.length} points`;e&&console.time(r),this.points=t;const n=[];for(let e=0;e<t.length;e++){const s=t[e];if(!s||!s.geometry)continue;const o=s.geometry.coordinates;if(!Array.isArray(o)||o.length<2)continue;const[r,i]=o,a=h(m(r)),c=h(y(i));n.push(a,c,1/0,e,-1,1),this.options.reduce&&n.push(0)}let i=this.trees[o+1]=this._createTree(n);e&&console.timeEnd(r);for(let t=o;t>=s;t--){const s=+Date.now();i=this.trees[t]=this._createTree(this._cluster(i,t)),e&&console.log("z%d: %d clusters in %dms",t,i.numItems,+Date.now()-s)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[1]));let r=180===t[2]?180:((t[2]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,r=180;else if(s>r){const t=this.getClusters([s,o,180,n],e),i=this.getClusters([-180,o,r,n],e);return t.concat(i)}const i=this.trees[this._limitZoom(e)],a=i.range(m(s),y(n),m(r),y(o)),h=i.data,c=[];for(const t of a){const e=this.stride*t;c.push(h[e+u]>1?l(h,e,this.clusterProps):this.points[h[e+p]])}return c}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),o="No cluster with the specified id.",r=this.trees[s];if(!r)throw new Error(o);const n=r.data;if(e*this.stride>=n.length)throw new Error(o);const i=this.options.radius/(this.options.extent*Math.pow(2,s-1)),a=n[e*this.stride],h=n[e*this.stride+1],c=r.within(a,h,i),d=[];for(const e of c){const s=e*this.stride;n[s+4]===t&&d.push(n[s+u]>1?l(n,s,this.clusterProps):this.points[n[s+p]])}if(0===d.length)throw new Error(o);return d}getLeaves(t,e,s){e=e||10,s=s||0;const o=[];return this._appendLeaves(o,t,e,s,0),o}getTile(t,e,s){const o=this.trees[this._limitZoom(t)],r=Math.pow(2,t),{extent:n,radius:i}=this.options,a=i/n,h=(s-a)/r,c=(s+1+a)/r,p={features:[]};return this._addTileFeatures(o.range((e-a)/r,h,(e+1+a)/r,c),o.data,e,s,r,p),0===e&&this._addTileFeatures(o.range(1-a/r,h,1,c),o.data,r,s,r,p),e===r-1&&this._addTileFeatures(o.range(0,h,a/r,c),o.data,-1,s,r,p),p.features.length?p:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,1!==s.length)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,o,r){const n=this.getChildren(e);for(const e of n){const n=e.properties;if(n&&n.cluster?r+n.point_count<=o?r+=n.point_count:r=this._appendLeaves(t,n.cluster_id,s,o,r):r<o?r++:t.push(e),t.length===s)break}return r}_createTree(t){const s=new e(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let e=0;e<t.length;e+=this.stride)s.add(t[e],t[e+1]);return s.finish(),s.data=t,s}_addTileFeatures(t,e,s,o,r,n){for(const i of t){const t=i*this.stride,a=e[t+u]>1;let h,c,d;if(a)h=f(e,t,this.clusterProps),c=e[t],d=e[t+1];else{const s=this.points[e[t+p]];h=s.properties;const[o,r]=s.geometry.coordinates;c=m(o),d=y(r)}const l={type:1,geometry:[[Math.round(this.options.extent*(c*r-s)),Math.round(this.options.extent*(d*r-o))]],tags:h};let g;g=a||this.options.generateId?e[t+p]:this.points[e[t+p]].id,void 0!==g&&(l.id=g),n.features.push(l)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:s,extent:o,reduce:r,minPoints:n}=this.options,i=s/(o*Math.pow(2,e)),a=t.data,h=[],c=this.stride;for(let s=0;s<a.length;s+=c){if(a[s+2]<=e)continue;a[s+2]=e;const o=a[s],p=a[s+1],d=t.within(a[s],a[s+1],i),l=a[s+u];let f=l;for(const t of d){const s=t*c;a[s+2]>e&&(f+=a[s+u])}if(f>l&&f>=n){let t,n=o*l,i=p*l,m=-1;const y=(s/c<<5)+(e+1)+this.points.length;for(const o of d){const h=o*c;if(a[h+2]<=e)continue;a[h+2]=e;const p=a[h+u];if(n+=a[h]*p,i+=a[h+1]*p,a[h+4]=y,r){if(!t){t=this._map(a,s,!0),t._byZoom=Object.create(null),t._originZoom=e;const o=t.propertyStatuses;t._byZoom[e]=o instanceof Set?Array.from(o):Array.isArray(o)?o.slice():[],m=this.clusterProps.length,this.clusterProps.push(t)}r(t,this._map(a,h),e)}}a[s+4]=y,h.push(n/f,i/f,1/0,y,-1,f),r&&h.push(m)}else{for(let t=0;t<c;t++)h.push(a[s+t]);if(f>1)for(const t of d){const s=t*c;if(!(a[s+2]<=e)){a[s+2]=e;for(let t=0;t<c;t++)h.push(a[s+t])}}}}return h}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+u]>1){const o=this.clusterProps[t[e+d]];return s?Object.assign({},o):o}const o=this.points[t[e+p]].properties,r=this.options.map(o);return s&&r===o?Object.assign({},r):r}}}));
